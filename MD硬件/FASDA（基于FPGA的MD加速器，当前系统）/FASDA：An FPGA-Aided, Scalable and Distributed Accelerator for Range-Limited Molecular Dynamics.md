# FASDA：An FPGA-Aided, Scalable and Distributed Accelerator for Range-Limited Molecular Dynamics

#### 为什么使用FPGA？

传统的加速MD的方法是有局限的：

- ASIC并不总是普遍可用的
- GPU在处理小分子时可能无法扩展

FPGA既是通信处理器，也是加速器，这些功能之间紧密耦合，因此可用于该领域的强扩展问题。

#### MD的难点：

- 为了实现精确度，MD需要在离散的、无限小的时间间隔内（几飞秒）进行迭代
- 迭代必须按顺序进行，因而并行化仅限于迭代内部

#### FPGA的优势：

- flexible and bespoke arithmetic
- custom computation pipelines
- complex custom routing of data streams among pipelines
- flexible low-latency inter-device communication

MD模拟的主要内容为短程力（Range-Limited）和长程力（Long-Range）的计算。RL是计算密集型的，消耗了大约90%的计算量，而RL则更注重内存和通信。这两个部分在数据流上基本独立，可以作为两个独立的任务来处理。

### FASDA由以下组件构成：

1. Cell Building Block(CBB)：它本身由计算、存储和路由单元组成。
2. 系统扩展为分布式分散设计，采用hyper-ring通信拓扑结构，使用链式同步和Cell ID转换进行同步
3. 使用可扩展处理单元（Scalable Processing Elements（SPEs））将原始CBB扩展为Scalable Cell Building Block（SCBB）。

![FASDA-1](.\图片\FASDA-1.png)

### 短程力：

短程力由两部分组成：使用Particle Mesh Ewald（PME）方法获得的静电力的短程项，以及从Lennard-Jones（LJ）势推导出的力。在本文中短程力指的是后者。

LJ势是一种经验势，用于描述电中性粒子之间的范德华力。距离为$r_{ij}$的粒子i和j之间的LJ势为：
$$
V^{LJ}_{ij}=4\epsilon_{ij}[(\frac{\sigma_{ij}}{r_{ij}})^{12}-(\frac{\sigma_{ij}}{r_{ij}})^6]
$$
其中$\epsilon$（色散能）描述了势的振幅，$\sigma$是零LJ势时的粒子特征距离。利用电势的梯度可以得到粒子i和j之间的短程力：
$$
F_{ij}^{LJ}=\frac{\epsilon_{ij}}{\sigma^2_{ij}}[48(\frac{\sigma_{ij}}{r_{ij}})^{14}-24(\frac{\sigma_{ij}}{r_{ij}})^8]r_{ij}
$$
可以观察到，随着$r_{ij}$的增加，力迅速衰减，这意味着可以在误差允许的限度内选择一个截止半径（$R_c$），从而只对半径中的粒子进行评估。这样，总体计算复杂度就变为了O(mN)，其中m是粒子的邻居粒子的平均数量，远远小于N。

利用牛顿第三定律进行优化：由于成对作用力适用于两个相关粒子，因此总计算量可以减少一半。



### 单元空间划分

![FASDA-2](.\图片\FASDA-2.png)

如图2，模拟空间被划分为边长为$R_c$（截止半径）的立方体单元。选择$R_c$是因为它既是**只保留26个可能相邻单元**的最小值，也是高效粒子对过滤的最大值，如图3所示。

**本地单元中的原子如何与邻居单元进行配对：**如图2（c）根据半壳法，假设A为中心单元中的粒子，则只有绿色相邻单元（NC）和A的本地单元（HC）中的粒子才能和A配对，因而HC中的粒子只需要发送到13个NC中进行配对，而其他13个灰色单元会将其粒子发送到HC中进行配对。

![FASDA-3](.\图片\FASDA-3.png)

**在短程力的FPGA实现中，邻居列表在每个时间步都要重新计算。**

为了能够并行访问，每个单元的内容都存储在不同的内存区域中。例如，在3 x 3 x 3的配置中，总共分配了27个内存区域用于存储粒子。

**为什么要对粒子进行过滤：**

**两个相邻单元中的所有粒子并非都是有效的。根据下式，理论上只有约15%的相邻粒子能与粒子形成有效配对**
$$
P=\frac{\frac{4}{3}\pi R_c^3}{27R_c^3}=15.5\%
$$

#### MD短程力工作流

![FASDA-4](.\图片\FASDA-4.png)

1. 首先，初始位置数据被传送到力计算流水线；
2. 在流水线中进行粒子对过滤和力计算；
3. 将计算出的部分力累加到里存储器中；
4. 在位移更新单元中，计算出的力被转换成速度差，然后与当前位置和速度进行积分；
5. 更新位置存储器和速度存储器；
6. 在MD短程力计算中重复过程1~5。

### 单个芯片架构

![FASDA-5](.\图片\FASDA-5.png)

单个FPGA板子上由4个CBB组成。

每个CBB由：

1. PE
2. 位移更新单元（MU）
3. 位置缓存（PC）用于存储定点格式的位置信息，代表单元中的位置偏移，表示其与本地单元的相对位置
4. 力缓存（FC）存储32位浮点的力
5. 速度缓存（VC）存储32位浮点的速度
6. 在Ring网络中的位置节点（PRN）
7. 在Ring网络中的力节点（FRN）
8. 在Ring网络中的位移更新节点（MURN）

每个CBB的ID（0~3）由相应单元在空间中的坐标决定，计算公式为：
$$
CID = D_yD_zx+D_zy+z
$$
其中，$D_y$和$D_z$分别代表y维和z维的单元数量，变量x，y，z是正整数，唯一标识单元在模拟空间的位置，

#### 模块接口

1. 位置环（沿PRN的橙色路径所示）：用于将粒子从一个单元引导到另一个单元，使得不同单元中的粒子进行配对。一个粒子的位置有多个目的单元。PRN按顺时针方向转发粒子位置。

2. 力环（沿FRN的绿色路径所示）：将施加在粒子上的力从一个PE转移到它们各自的本地单元。粒子的力只有一个目的地。FRN按逆时针方向转发粒子力。

3. 位移更新环（沿MURN的路径所示）：用于处理粒子从一个单元迁移到另一个单元的情况，将迁移的粒子传送到目标单元。

由图5右侧放大的部分可知，PE仅根据位置数据计算得到力，并将产生的部分力直接传递给FC。而MU则需要对当前位置，力和速度进行积分以得到后续时间步的位置和速度。

#### PE功能

![FASDA-6](.\图片\FASDA-6.png)

当邻居位置到达PRN时，会对其进行检查，以确定本地PE是否时其目的地之一。**如果通过检查，该位置会被分派到其中一个寄存器，与重复遍历的位置缓存中本地原子的位置进行配对**

当粒子对通过过滤器时，就意味着这两个粒子足够接近，可以进行评估。然后粒子会被缓冲和仲裁，进入力流水线进行力计算。**计算出的力被分成两路：一路作为原点力直接发送到本地FC，另一路作为邻居力在本地取反并累加。**

为了累加和存储邻居力，会根据输入力的标识选择一个寄存器。然后将寄存器的内容与输入的力相结合，取代寄存器的旧值。**在完成对邻居粒子的评估后，就会选择相应的邻居力，并通过FRN传回其原本地单元。**

### 可扩展架构

#### Hyper-ring通信拓扑结构

![FASDA-8](.\图片\FASDA-8.png)

hyper-ring可以以相对小的开销增加PE或节点，但是远距离的通信时会加大对带宽的需求。不过，短程力计算中，相邻节点的数量有限，所以延迟开销和带宽需求只会随着系统规模的增大而少量增长，避免了远距离通信的带宽下降。

图8显示了用于FPGA间连接的hyper-ring。为片内子网络中的位置环（PR）和力环（FR）增加了一个EX节点，用以和外部FPGA节点交换数据并将其加入到片内子网络中，且只增加了一个环的延迟。

#### 单元ID转换

为了保持FPGA节点和CBB之间的一致性，设置了两级ID转换：一级是将全局单元ID（GCID）转换为本地单元ID（LCID），另一级是将本地单元ID转换为相对单元ID（RCID）。**每个单元都有一个唯一的GCID。也就是说，每个单元都有一个唯一的邻居单元ID列表。**

![FASDA-9](.\图片\FASDA-9.png)

分析图9的例子，GCID是从Node(0, 0)左下角的单元为原点(0, 0)编码的，所以左边例子中源粒子所处单元的位置为(5, 2)；右边例子中源粒子的位置为 (2, 1)。 

LCID则是以目的节点左下角的单元为原点(0, 0)编码的，所以左边的例子中以Node(0, 0)的左下角单元为原点(0, 0)，所以源粒子所处单元的LCID为(5, 2)；右边的例子中以Node(1, 0)的左下角单元为原点(0, 0)，由于单元之间的坐标是循环的，即图9中GCID为(5, 2)的单元和GCID为(0, 2)的单元是相邻的，且坐标为无符号数，所以源粒子所处单元的LCID为(5, 1)。

**GCID和LCID的区别就是：GCID是一定以节点0中左下角单元为原点(0, 0)，而LCID则是以本地节点左下角单元为原点(0, 0)。**

**在RCID编码中，RCID在每个方向上的范围为1~3，粒子将其所处单元的RCID编码为(2, 2)**，即可以看作以这个单元为中心单元的节点。所以左边例子中，目的单元的RCID为(2, 2)，而源单元在LCID上相对其是向左移动1次，所以源单元相对目的单元的RCID为(1, 2)；右边例子中，目的单元的RCID为(2, 2)，而源单元在LCID上相对其是向左移动一次，并向上移动一次，所以源单元相对于目的单元的RCID为(1, 3)。

#### 通信接口

图10所示，当包到达时，接受到一个包含四个数据片段的512位AXI-Stream位置（或力）包，并将其解包为单独的数据片段，片段头包含粒子识别信息（图11（a））。然后将数据序列化并发送到位置（或力）环上的EX节点，将其注入本地子环中进行进一步处理。

位置包可能有多个目的地，所以为了封装位置包，封装链重复使用位置数据，以减少扇出。P2R封装其可视为一个出发门。**位置数据通过一系列n P2R封装器找到其出发门，其中n是本地位置可传输到的相邻FPGA的数量。**如图11（b）所示，四个位置被封装为一个位置数据包，并在四个寄存器全部填满后进行缓冲，然后进行仲裁，以便分发。

力包只有一个目的地，因此一个周期为最多只有一个力包发出，无需仲裁器。

**位置包和力包都包含最后last同步信号，该信号在处理完与目的节点相关的所有数据后激活。**

![FASDA-10](.\图片\FASDA-10.png)

![FASDA-11](.\图片\FASDA-11.png)

#### 链式同步

**分布式空间仿真通常使用批量同步并行（BSP）模型，由于其集中性和易受流浪者问题（由于数据的异构和通信效率的不一致，需要等待最慢的设备把数据返回之后才能进行下一轮训练）的影响，单个工作节点的延迟会减慢整个系统的运行速度，因此这种模型可能会存在问题。**因而在MD中实现了链式同步方法。

![FASDA-12](.\图片\FASDA-12.png)

如图12所示，链式同步方法是在FPGA之间使用局部、细粒度同步。每个FPGA只以链式方法与其邻居同步。虽然链式通过方法仍依赖于最慢的board来完成，但它将远处的FPGA节点与速度慢的节点分离开，为它们提供了进入下一次迭代的先机，同时保留了分散和同质的系统。

![FASDA-13](.\图片\FASDA-13.png)

图13展示了链同步方法的运行过程（不包含位移更新阶段）：

1. 首先，节点0和节点1互相发送各自的位置数据。节点1在本地PR路由所有位置后，会在发送包的同时发送last position信号。
2. 节点0收到该信号后，认为只有在处理完从节点1接收到的所有位置后，才能返回last force信号，作为对last position信号的反馈。这一过程是相互的，节点0也会向节点1发送last position信号，并从节点1接收last force信号。
3. 当满足所有四个条件后，节点就可以独立进入位移更新阶段。
4. 位移更新阶段遵循类似但简化的同步模式，因为只有一个信号会被节点发送和接收。

**当一个FPGA节点需要与多个相邻的FPGA同步时，同步模式保持不变，但会添加计数器来维护接收到的last position和last force信号的数量。当发送或接收到的last信号数需要与邻居节点数相同。**

#### PE扩展结构（SPE）

**每个SPE由n个PE，n+1个FC，1个PC，1个PRN和一个FRN组成。**

使用多个PE来处理单个单元。

![FASDA-14](.\图片\FASDA-14.png)

一个PE中可以并行处理很多邻居位置，**但是处理每个位置数据仍需要超过100个周期**，这给予了位置环充足的路由时间。因此，单个PR足以为多个PE提供邻居位置数据。因为同一个单元由所有PE进行计算，所以PC中的本地位置可以很容易的广播给所有PE。

理论上每个周期会产生一对部分力。本地力分量直接累加到FC中，因此需要增加FC数量。邻居力先在PE中累加，然后仲裁并注入到FR中以进行路由。由于缩短的FR增加了吞吐量，所以设计了FC N用于存储邻居力，本地FRN会将邻居力传送到FC N。

FC中的力按粒子ID进行存储和索引，以保持内存对齐。简化力数据通路，将其在位移更新过程中累加，由图14右侧所示。FC需保持每个周期的吞吐量与MU匹配。

**PE扩展带来的优化：更短的路由环，只需根据PE数量扩展FC，而不需要扩展PC和VC（节约内存）**

#### CBB扩展结构（SCBB）

当PE增加到某种程度时，由于路由环和PC广播的限制带宽，性能不会再增加。此时就需要扩展CBB以获得更高的吞吐量。

图15是一个扩展的CBB的架构。包含两个SPE。

![FASDA-15](.\图片\FASDA-15.png)

由于瓶颈出现在环路由环和PC中，所以在一个SPE中减少PE，而增加额外的SPE来确保性能。**额外的SPE使用单独的路由路径来确保一样短的环。**两个SPE在单个SCBB中处理同一个单元，所以可以直接在加法器树中累加两个SPE算出的力。

SCBB中VC和MC没有扩展，而环上的EX节点扩展了，用与其他FPGA节点共享带宽。为了防止PRN传输重复的邻居位置，所有本地单元的粒子位置被分为两个不相交的子集存储在$PC_0$和$PC_1$中（$PC_0$只存储粒子ID为偶数的位置、$PC_1$仅存储奇数）。**这些$PC$仅负责向邻居广播粒子位置，而本地位置缓存（$HPC$）负责让PE遍历本地粒子位置。在本地MU更新时，$PC_0$、$PC_1$和$HPC$被同时更新。**

### 评测

#### FASDA的实验平台

我们的实验是在开放云测试平台[23]上进行的，使用了多达 8 个 **Xilinx UltraScale+ Alveo U280 FPGA 板卡，运行频率为 200 MHz**，两个 QSFP28 端口均连接到戴尔 Z9100-ON 100 GbE 交换机，并建立了 UDP 协议。

#### 总体性能

![FASDA-16](.\图片\FASDA-16.png)

前四个空间按$3\times 3 \times 3$放大以展示弱可扩展性，最后一个$4\times 4 \times4$用于展示强可扩展性。

在前四种配置下，FPGA的仿真速率始终保持在$2 \mu s/day$左右。

#### 组件利用率

![FASDA-17](.\图片\FASDA-17.png)

硬件利用率可以表明组件执行的平均工作量与其容量的对比，而时间利用率则表示组件处于活动状态的平均时间比例，在此期间里，流水线可能没有满，但仍在运行。

#### 通信强度

![FASDA-18](.\图片\FASDA-18.png)

在实验中，使用QSFP28端口进行位置和力通信。

由图18（A）可知，即使在2-SPE和3-PE的强可扩展配置中，FPGA对位置或力的平均带宽需求也低于25Gbps，远低于可用的100Gbps。**然而，通信强度的峰值可能会使路由设备（如交换机）不堪重负，导致数据包丢失，因此我们使用冷却计数器将每块板卡的传输限制为每几个周期一次，从而有效地将峰值分散到一段时间内。**由于通信和计算是同时执行的，而计算的强度通常远大于通信，因此冷却造成的通信延迟损失被隐藏起来。

图18（B）展示了与其他FPGA节点的位置和力通信强度的细分百分比。

#### 资源占用

![FASDA-Table1](.\图片\FASDA-Table1.png)

表1列出了各种实现的系统在**Xilinx UltraScale+ Alveo U280 FPGA 板卡**上的资源占用。